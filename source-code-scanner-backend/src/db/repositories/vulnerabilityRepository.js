// src/db/repositories/vulnerabilityRepository.js - FINAL FIXED VERSION
const Vulnerability = require('../models/vulnerabilityModel');
const { logger } = require('../../utils/logger');

class VulnerabilityRepository {
  /**
   * Create a new vulnerability
   * @param {Object} vulnerabilityData - Vulnerability data
   * @returns {Object} Created vulnerability
   */
  async createVulnerability(vulnerabilityData) {
    try {
      const vulnerability = new Vulnerability(vulnerabilityData);
      await vulnerability.save();
      return vulnerability;
    } catch (error) {
      logger.error(`Error creating vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Create multiple vulnerabilities in bulk - FINAL FIXED VERSION
   * @param {Array} vulnerabilitiesData - Array of vulnerability data
   * @returns {Array} Created vulnerabilities
   */
  async createBulkVulnerabilities(vulnerabilitiesData) {
    try {
      console.log(`📦 Bulk inserting ${vulnerabilitiesData.length} vulnerabilities...`);
      
      // Validate input data before insertion
      if (!Array.isArray(vulnerabilitiesData) || vulnerabilitiesData.length === 0) {
        throw new Error('Invalid or empty vulnerabilities data array');
      }
      
      // ENHANCED: Clean and validate data before insertion
      const cleanedData = vulnerabilitiesData.map((vuln, index) => {
        try {
          // Ensure required fields exist with defaults
          const cleaned = {
            ...vuln,
            codeSnippet: {
              line: vuln.codeSnippet?.line || 'Code snippet not available',
              before: vuln.codeSnippet?.before || [],
              after: vuln.codeSnippet?.after || []
            },
            references: Array.isArray(vuln.references) ? vuln.references : []
          };
          
          return cleaned;
        } catch (cleanError) {
          console.error(`Error cleaning vulnerability ${index}:`, cleanError.message);
          throw cleanError;
        }
      });
      
      console.log(`📝 Sample cleaned vulnerability:`, JSON.stringify(cleanedData[0], null, 2));
      
      const result = await Vulnerability.insertMany(cleanedData);
      console.log(`✅ Successfully inserted ${result.length} vulnerabilities`);
      return result;
    } catch (error) {
      // FINAL FIX: Remove all .error references
      console.error(`❌ Bulk insert error:`, error.message);
      logger.error(`Error creating bulk vulnerabilities: ${error.message}`);
      
      // Enhanced error logging
      if (error.writeErrors) {
        console.error(`Write errors count:`, error.writeErrors.length);
        error.writeErrors.slice(0, 3).forEach((writeError, index) => {
          console.error(`Write error ${index + 1}:`, writeError.errmsg);
        });
      }
      
      if (error.result) {
        console.error(`Insert result:`, {
          insertedCount: error.result.insertedCount,
          writeErrorCount: error.result.writeErrors?.length || 0
        });
      }
      
      // Detailed validation error logging
      if (error.errors) {
        console.error('Validation errors:');
        Object.entries(error.errors).forEach(([field, err]) => {
          console.error(`  ${field}: ${err.message}`);
        });
      }
      
      throw error; // Re-throw the original error
    }
  }

  /**
   * Get vulnerability by ID
   * @param {String} vulnerabilityId - Vulnerability ID
   * @returns {Object} Vulnerability
   */
  async getVulnerabilityById(vulnerabilityId) {
    try {
      return await Vulnerability.findById(vulnerabilityId)
        .populate('scan')
        .populate('assignedTo', 'username firstName lastName')
        .populate('comments.user', 'username firstName lastName');
    } catch (error) {
      logger.error(`Error getting vulnerability by ID: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get vulnerabilities by scan ID
   * @param {String} scanId - Scan ID
   * @param {Object} filter - Additional filter criteria
   * @param {Number} limit - Maximum number of results
   * @param {Number} skip - Number of results to skip
   * @returns {Array} Vulnerabilities
   */
  async getVulnerabilitiesByScan(scanId, filter = {}, limit = 1000, skip = 0) {
    try {
      return await Vulnerability.find({ scan: scanId, ...filter })
        .populate('assignedTo', 'username firstName lastName')
        .sort({ severity: 1, createdAt: -1 })
        .limit(limit)
        .skip(skip);
    } catch (error) {
      logger.error(`Error getting vulnerabilities by scan: ${error.message}`);
      throw error;
    }
  }

  /**
   * Update vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {Object} updateData - Data to update
   * @returns {Object} Updated vulnerability
   */
  async updateVulnerability(vulnerabilityId, updateData) {
    try {
      updateData.updatedAt = new Date();
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        updateData,
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error updating vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Update vulnerability status
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} status - New status
   * @param {String} userId - User ID who made the change
   * @param {String} comment - Optional comment
   * @returns {Object} Updated vulnerability
   */
  async updateVulnerabilityStatus(vulnerabilityId, status, userId, comment) {
    try {
      const update = {
        status,
        updatedAt: new Date()
      };
      
      if (status === 'fixed') {
        update.fixedAt = new Date();
      }
      
      if (comment) {
        const newComment = {
          text: comment,
          user: userId,
          createdAt: new Date()
        };
        
        return await Vulnerability.findByIdAndUpdate(
          vulnerabilityId,
          {
            ...update,
            $push: { comments: newComment }
          },
          { new: true, runValidators: true }
        );
      }
      
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        update,
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error updating vulnerability status: ${error.message}`);
      throw error;
    }
  }

  /**
   * Add comment to vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} comment - Comment text
   * @param {String} userId - User ID
   * @returns {Object} Updated vulnerability
   */
  async addComment(vulnerabilityId, comment, userId) {
    try {
      const newComment = {
        text: comment,
        user: userId,
        createdAt: new Date()
      };
      
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        {
          $push: { comments: newComment },
          updatedAt: new Date()
        },
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error adding comment to vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Assign vulnerability to user
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} userId - User ID
   * @returns {Object} Updated vulnerability
   */
  async assignVulnerability(vulnerabilityId, userId) {
    try {
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        {
          assignedTo: userId,
          updatedAt: new Date()
        },
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error assigning vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Delete vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @returns {Object} Deleted vulnerability
   */
  async deleteVulnerability(vulnerabilityId) {
    try {
      return await Vulnerability.findByIdAndDelete(vulnerabilityId);
    } catch (error) {
      logger.error(`Error deleting vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Delete all vulnerabilities for a scan
   * @param {String} scanId - Scan ID
   * @returns {Object} Delete result
   */
  async deleteVulnerabilitiesByScan(scanId) {
    try {
      return await Vulnerability.deleteMany({ scan: scanId });
    } catch (error) {
      logger.error(`Error deleting vulnerabilities by scan: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get vulnerability statistics by scan
   * @param {String} scanId - Scan ID
   * @returns {Object} Statistics
   */
  async getVulnerabilityStatsByScan(scanId) {
    try {
      // Count by severity
      const severityStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$severity', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by type
      const typeStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$type', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by tool
      const toolStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$tool', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by status
      const statusStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$status', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by file
      const fileStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$file.fileName', 
          count: { $sum: 1 } 
        }},
        { $sort: { count: -1 } },
        { $limit: 10 }
      ]);
      
      // Transform to a more usable format
      const transformStats = (stats) => {
        const result = {};
        stats.forEach(stat => {
          result[stat._id] = stat.count;
        });
        return result;
      };
      
      return {
        totalVulnerabilities: await Vulnerability.countDocuments({ scan: scanId }),
        bySeverity: transformStats(severityStats),
        byType: transformStats(typeStats),
        byTool: transformStats(toolStats),
        byStatus: transformStats(statusStats),
        topFiles: fileStats.map(file => ({
          fileName: file._id,
          count: file.count
        }))
      };
    } catch (error) {
      logger.error(`Error getting vulnerability statistics: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get all vulnerabilities with optional filtering
   * @param {Object} filter - Filter criteria
   * @param {Number} limit - Maximum number of results
   * @param {Number} skip - Number of results to skip
   * @returns {Array} List of vulnerabilities
   */
  async getVulnerabilities(filter = {}, limit = 100, skip = 0) {
    try {
      return await Vulnerability.find(filter)
        .populate('scan')
        .populate('assignedTo', 'username firstName lastName')
        .sort({ createdAt: -1 })
        .limit(limit)
        .skip(skip);
    } catch (error) {
      logger.error(`Error getting vulnerabilities: ${error.message}`);
      throw error;
    }
  }

  /**
   * Count vulnerabilities with optional filtering
   * @param {Object} filter - Filter criteria
   * @returns {Number} Count of vulnerabilities
   */
  async countVulnerabilities(filter = {}) {
    try {
      return await Vulnerability.countDocuments(filter);
    } catch (error) {
      logger.error(`Error counting vulnerabilities: ${error.message}`);
      throw error;
    }
  }
}

module.exports = new VulnerabilityRepository();