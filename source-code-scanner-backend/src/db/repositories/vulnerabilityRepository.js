// src/db/repositories/vulnerabilityRepository.js
const Vulnerability = require('../models/vulnerabilityModel');
const { logger } = require('../../utils/logger');

class VulnerabilityRepository {
  /**
   * Create a new vulnerability
   * @param {Object} vulnerabilityData - Vulnerability data
   * @returns {Object} Created vulnerability
   */
  async createVulnerability(vulnerabilityData) {
    try {
      const vulnerability = new Vulnerability(vulnerabilityData);
      await vulnerability.save();
      return vulnerability;
    } catch (error) {
      logger.error(`Error creating vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Create multiple vulnerabilities in bulk
   * @param {Array} vulnerabilitiesData - Array of vulnerability data
   * @returns {Array} Created vulnerabilities
   */
  async createBulkVulnerabilities(vulnerabilitiesData) {
    try {
      return await Vulnerability.insertMany(vulnerabilitiesData);
    } catch (error) {
      logger.error(`Error creating bulk vulnerabilities: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get vulnerability by ID
   * @param {String} vulnerabilityId - Vulnerability ID
   * @returns {Object} Vulnerability
   */
  async getVulnerabilityById(vulnerabilityId) {
    try {
      return await Vulnerability.findById(vulnerabilityId)
        .populate('scan')
        .populate('assignedTo', 'username firstName lastName')
        .populate('comments.user', 'username firstName lastName');
    } catch (error) {
      logger.error(`Error getting vulnerability by ID: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get vulnerabilities by scan ID
   * @param {String} scanId - Scan ID
   * @param {Object} filter - Additional filter criteria
   * @param {Number} limit - Maximum number of results
   * @param {Number} skip - Number of results to skip
   * @returns {Array} Vulnerabilities
   */
  async getVulnerabilitiesByScan(scanId, filter = {}, limit = 1000, skip = 0) {
    try {
      return await Vulnerability.find({ scan: scanId, ...filter })
        .populate('assignedTo', 'username firstName lastName')
        .sort({ severity: 1, createdAt: -1 }) // Sort by severity (critical first) then by creation date
        .limit(limit)
        .skip(skip);
    } catch (error) {
      logger.error(`Error getting vulnerabilities by scan: ${error.message}`);
      throw error;
    }
  }

  /**
   * Update vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {Object} updateData - Data to update
   * @returns {Object} Updated vulnerability
   */
  async updateVulnerability(vulnerabilityId, updateData) {
    try {
      updateData.updatedAt = new Date();
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        updateData,
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error updating vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Update vulnerability status
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} status - New status
   * @param {String} userId - User ID who made the change
   * @param {String} comment - Optional comment
   * @returns {Object} Updated vulnerability
   */
  async updateVulnerabilityStatus(vulnerabilityId, status, userId, comment) {
    try {
      const update = {
        status,
        updatedAt: new Date()
      };
      
      // If status is 'fixed', set fixedAt
      if (status === 'fixed') {
        update.fixedAt = new Date();
      }
      
      // Add comment if provided
      if (comment) {
        const newComment = {
          text: comment,
          user: userId,
          createdAt: new Date()
        };
        
        return await Vulnerability.findByIdAndUpdate(
          vulnerabilityId,
          {
            ...update,
            $push: { comments: newComment }
          },
          { new: true, runValidators: true }
        );
      }
      
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        update,
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error updating vulnerability status: ${error.message}`);
      throw error;
    }
  }

  /**
   * Add comment to vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} comment - Comment text
   * @param {String} userId - User ID
   * @returns {Object} Updated vulnerability
   */
  async addComment(vulnerabilityId, comment, userId) {
    try {
      const newComment = {
        text: comment,
        user: userId,
        createdAt: new Date()
      };
      
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        {
          $push: { comments: newComment },
          updatedAt: new Date()
        },
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error adding comment to vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Assign vulnerability to user
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} userId - User ID
   * @returns {Object} Updated vulnerability
   */
  async assignVulnerability(vulnerabilityId, userId) {
    try {
      return await Vulnerability.findByIdAndUpdate(
        vulnerabilityId,
        {
          assignedTo: userId,
          updatedAt: new Date()
        },
        { new: true, runValidators: true }
      );
    } catch (error) {
      logger.error(`Error assigning vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Delete vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @returns {Object} Deleted vulnerability
   */
  async deleteVulnerability(vulnerabilityId) {
    try {
      return await Vulnerability.findByIdAndDelete(vulnerabilityId);
    } catch (error) {
      logger.error(`Error deleting vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Delete all vulnerabilities for a scan
   * @param {String} scanId - Scan ID
   * @returns {Object} Delete result
   */
  async deleteVulnerabilitiesByScan(scanId) {
    try {
      return await Vulnerability.deleteMany({ scan: scanId });
    } catch (error) {
      logger.error(`Error deleting vulnerabilities by scan: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get vulnerability statistics by scan
   * @param {String} scanId - Scan ID
   * @returns {Object} Statistics
   */
  async getVulnerabilityStatsByScan(scanId) {
    try {
      // Count by severity
      const severityStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$severity', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by type
      const typeStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$type', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by tool
      const toolStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$tool', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by status
      const statusStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$status', 
          count: { $sum: 1 } 
        }}
      ]);
      
      // Count by file
      const fileStats = await Vulnerability.aggregate([
        { $match: { scan: scanId } },
        { $group: { 
          _id: '$file.fileName', 
          count: { $sum: 1 } 
        }},
        { $sort: { count: -1 } },
        { $limit: 10 }
      ]);
      
      // Transform to a more usable format
      const transformStats = (stats) => {
        const result = {};
        stats.forEach(stat => {
          result[stat._id] = stat.count;
        });
        return result;
      };
      
      return {
        totalVulnerabilities: await Vulnerability.countDocuments({ scan: scanId }),
        bySeverity: transformStats(severityStats),
        byType: transformStats(typeStats),
        byTool: transformStats(toolStats),
        byStatus: transformStats(statusStats),
        topFiles: fileStats.map(file => ({
          fileName: file._id,
          count: file.count
        }))
      };
    } catch (error) {
      logger.error(`Error getting vulnerability statistics: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get all vulnerabilities with optional filtering
   * @param {Object} filter - Filter criteria
   * @param {Number} limit - Maximum number of results
   * @param {Number} skip - Number of results to skip
   * @returns {Array} List of vulnerabilities
   */
  async getVulnerabilities(filter = {}, limit = 100, skip = 0) {
    try {
      return await Vulnerability.find(filter)
        .populate('scan')
        .populate('assignedTo', 'username firstName lastName')
        .sort({ createdAt: -1 })
        .limit(limit)
        .skip(skip);
    } catch (error) {
      logger.error(`Error getting vulnerabilities: ${error.message}`);
      throw error;
    }
  }

  /**
   * Count vulnerabilities with optional filtering
   * @param {Object} filter - Filter criteria
   * @returns {Number} Count of vulnerabilities
   */
  async countVulnerabilities(filter = {}) {
    try {
      return await Vulnerability.countDocuments(filter);
    } catch (error) {
      logger.error(`Error counting vulnerabilities: ${error.message}`);
      throw error;
    }
  }
}

module.exports = new VulnerabilityRepository();