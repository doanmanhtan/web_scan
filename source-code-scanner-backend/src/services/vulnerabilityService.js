// src/services/vulnerabilityService.js
const { logger } = require('../utils/logger');
const vulnerabilityRepository = require('../db/repositories/vulnerabilityRepository');
const scanRepository = require('../db/repositories/scanRepository');
const { getCodeSnippet } = require('../utils/codeParser');

/**
 * Service for managing vulnerabilities
 */
class VulnerabilityService {
  /**
   * Get vulnerability by ID
   * @param {String} vulnerabilityId - Vulnerability ID
   * @returns {Object} Vulnerability
   */
  async getVulnerabilityById(vulnerabilityId) {
    try {
      return await vulnerabilityRepository.getVulnerabilityById(vulnerabilityId);
    } catch (error) {
      logger.error(`Error getting vulnerability by ID: ${error.message}`);
      // src/services/vulnerabilityService.js (tiếp tục)
      throw error;
    }
  }

  /**
   * Get vulnerabilities by scan ID
   * @param {String} scanId - Scan ID
   * @param {Object} filter - Filter criteria
   * @param {Number} limit - Maximum number of results
   * @param {Number} skip - Number of results to skip
   * @returns {Object} Vulnerabilities with pagination
   */
  async getVulnerabilitiesByScan(scanId, filter = {}, limit = 100, skip = 0) {
    try {
      const scan = await scanRepository.getScanById(scanId);
      
      if (!scan) {
        throw new Error(`Scan not found: ${scanId}`);
      }
      
      const vulnerabilities = await vulnerabilityRepository.getVulnerabilitiesByScan(
        scanId, filter, limit, skip
      );
      
      const total = await vulnerabilityRepository.countVulnerabilities({
        ...filter,
        scan: scanId
      });
      
      return {
        vulnerabilities,
        pagination: {
          total,
          limit,
          skip,
          hasMore: total > skip + limit
        }
      };
    } catch (error) {
      logger.error(`Error getting vulnerabilities by scan: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get vulnerability statistics by scan
   * @param {String} scanId - Scan ID
   * @returns {Object} Vulnerability statistics
   */
  async getVulnerabilityStatsByScan(scanId) {
    try {
      const scan = await scanRepository.getScanById(scanId);
      
      if (!scan) {
        throw new Error(`Scan not found: ${scanId}`);
      }
      
      return await vulnerabilityRepository.getVulnerabilityStatsByScan(scanId);
    } catch (error) {
      logger.error(`Error getting vulnerability statistics: ${error.message}`);
      throw error;
    }
  }

  /**
   * Update vulnerability status
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} status - New status
   * @param {String} userId - User ID who made the change
   * @param {String} comment - Optional comment
   * @returns {Object} Updated vulnerability
   */
  async updateVulnerabilityStatus(vulnerabilityId, status, userId, comment) {
    try {
      const vulnerability = await vulnerabilityRepository.getVulnerabilityById(vulnerabilityId);
      
      if (!vulnerability) {
        throw new Error(`Vulnerability not found: ${vulnerabilityId}`);
      }
      
      // Validate status
      const validStatuses = ['open', 'in_progress', 'fixed', 'ignored', 'false_positive'];
      if (!validStatuses.includes(status)) {
        throw new Error(`Invalid status: ${status}`);
      }
      
      return await vulnerabilityRepository.updateVulnerabilityStatus(
        vulnerabilityId, status, userId, comment
      );
    } catch (error) {
      logger.error(`Error updating vulnerability status: ${error.message}`);
      throw error;
    }
  }

  /**
   * Add comment to vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} comment - Comment text
   * @param {String} userId - User ID
   * @returns {Object} Updated vulnerability
   */
  async addComment(vulnerabilityId, comment, userId) {
    try {
      const vulnerability = await vulnerabilityRepository.getVulnerabilityById(vulnerabilityId);
      
      if (!vulnerability) {
        throw new Error(`Vulnerability not found: ${vulnerabilityId}`);
      }
      
      if (!comment || comment.trim() === '') {
        throw new Error('Comment cannot be empty');
      }
      
      return await vulnerabilityRepository.addComment(vulnerabilityId, comment, userId);
    } catch (error) {
      logger.error(`Error adding comment to vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Assign vulnerability to user
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {String} userId - User ID
   * @returns {Object} Updated vulnerability
   */
  async assignVulnerability(vulnerabilityId, userId) {
    try {
      const vulnerability = await vulnerabilityRepository.getVulnerabilityById(vulnerabilityId);
      
      if (!vulnerability) {
        throw new Error(`Vulnerability not found: ${vulnerabilityId}`);
      }
      
      return await vulnerabilityRepository.assignVulnerability(vulnerabilityId, userId);
    } catch (error) {
      logger.error(`Error assigning vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Update vulnerability details
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {Object} updateData - Data to update
   * @returns {Object} Updated vulnerability
   */
  async updateVulnerability(vulnerabilityId, updateData) {
    try {
      const vulnerability = await vulnerabilityRepository.getVulnerabilityById(vulnerabilityId);
      
      if (!vulnerability) {
        throw new Error(`Vulnerability not found: ${vulnerabilityId}`);
      }
      
      // Filter allowed fields for update
      const allowedFields = ['severity', 'type', 'description', 'remediation'];
      const filteredUpdate = {};
      
      Object.keys(updateData).forEach(key => {
        if (allowedFields.includes(key)) {
          filteredUpdate[key] = updateData[key];
        }
      });
      
      return await vulnerabilityRepository.updateVulnerability(vulnerabilityId, filteredUpdate);
    } catch (error) {
      logger.error(`Error updating vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get code snippet for vulnerability
   * @param {String} vulnerabilityId - Vulnerability ID
   * @param {Number} contextLines - Number of context lines before and after
   * @returns {Object} Code snippet
   */
  async getCodeSnippet(vulnerabilityId, contextLines = 3) {
    try {
      const vulnerability = await vulnerabilityRepository.getVulnerabilityById(vulnerabilityId);
      
      if (!vulnerability) {
        throw new Error(`Vulnerability not found: ${vulnerabilityId}`);
      }
      
      const scan = await scanRepository.getScanById(vulnerability.scan);
      
      if (!scan) {
        throw new Error(`Scan not found for vulnerability: ${vulnerabilityId}`);
      }
      
      // Construct file path
      const filePath = path.join(scan.scanDirectory, 'uploads', vulnerability.file.filePath);
      
      // Get code snippet
      const snippet = await getCodeSnippet(
        filePath, 
        vulnerability.location.line,
        contextLines
      );
      
      return snippet;
    } catch (error) {
      logger.error(`Error getting code snippet for vulnerability: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get all vulnerabilities with optional filtering
   * @param {Object} filter - Filter criteria
   * @param {Number} limit - Maximum number of results
   * @param {Number} skip - Number of results to skip
   * @returns {Object} Vulnerabilities with pagination
   */
  async getVulnerabilities(filter = {}, limit = 100, skip = 0) {
    try {
      const vulnerabilities = await vulnerabilityRepository.getVulnerabilities(
        filter, limit, skip
      );
      
      const total = await vulnerabilityRepository.countVulnerabilities(filter);
      
      return {
        vulnerabilities,
        pagination: {
          total,
          limit,
          skip,
          hasMore: total > skip + limit
        }
      };
    } catch (error) {
      logger.error(`Error getting vulnerabilities: ${error.message}`);
      throw error;
    }
  }

  /**
   * Search vulnerabilities
   * @param {String} searchTerm - Search term
   * @param {Object} filter - Additional filter criteria
   * @param {Number} limit - Maximum number of results
   * @param {Number} skip - Number of results to skip
   * @returns {Object} Vulnerabilities with pagination
   */
  async searchVulnerabilities(searchTerm, filter = {}, limit = 100, skip = 0) {
    try {
      // Create search filter
      const searchFilter = {
        ...filter,
        $or: [
          { name: { $regex: searchTerm, $options: 'i' } },
          { description: { $regex: searchTerm, $options: 'i' } },
          { 'file.fileName': { $regex: searchTerm, $options: 'i' } }
        ]
      };
      
      return await this.getVulnerabilities(searchFilter, limit, skip);
    } catch (error) {
      logger.error(`Error searching vulnerabilities: ${error.message}`);
      throw error;
    }
  }
}

module.exports = new VulnerabilityService();