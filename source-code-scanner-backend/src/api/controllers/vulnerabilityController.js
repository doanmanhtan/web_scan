// src/api/controllers/vulnerabilityController.js
const vulnerabilityService = require('../../services/vulnerabilityService');
const logger = require('../../utils/logger');

/**
 * Vulnerability controller
 */
const vulnerabilityController = {
  /**
   * Get vulnerability by ID
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  getVulnerabilityById: async (req, res) => {
    try {
      const vulnerabilityId = req.params.id;
      
      const vulnerability = await vulnerabilityService.getVulnerabilityById(vulnerabilityId);
      
      if (!vulnerability) {
        return res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        });
      }
      
      res.status(200).json({
        success: true,
        data: vulnerability
      });
    } catch (error) {
      logger.error(`Error in getVulnerabilityById controller: ${error.message}`);
      
      res.status(500).json({
        success: false,
        message: 'Error fetching vulnerability'
      });
    }
  },

  /**
   * Update vulnerability status
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  updateStatus: async (req, res) => {
    try {
      const vulnerabilityId = req.params.id;
      const { status, comment } = req.body;
      const userId = req.user.id;
      
      const updatedVulnerability = await vulnerabilityService.updateVulnerabilityStatus(
        vulnerabilityId,
        status,
        userId,
        comment
      );
      
      res.status(200).json({
        success: true,
        message: 'Vulnerability status updated successfully',
        data: updatedVulnerability
      });
    } catch (error) {
      logger.error(`Error in updateStatus controller: ${error.message}`);
      
      if (error.message.includes('not found')) {
        return res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        });
      }
      
      if (error.message.includes('Invalid status')) {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }
      
      res.status(500).json({
        success: false,
        message: 'Error updating vulnerability status'
      });
    }
  },

  /**
   * Add comment to vulnerability
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  addComment: async (req, res) => {
    try {
      const vulnerabilityId = req.params.id;
      const { comment } = req.body;
      const userId = req.user.id;
      
      const updatedVulnerability = await vulnerabilityService.addComment(
        vulnerabilityId,
        comment,
        userId
      );
      
      res.status(200).json({
        success: true,
        message: 'Comment added successfully',
        data: updatedVulnerability
      });
    } catch (error) {
      logger.error(`Error in addComment controller: ${error.message}`);
      
      if (error.message.includes('not found')) {
        return res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        });
      }
      
      if (error.message === 'Comment cannot be empty') {
        return res.status(400).json({
          success: false,
          message: error.message
        });
      }
      
      res.status(500).json({
        success: false,
        message: 'Error adding comment'
      });
    }
  },

  /**
   * Assign vulnerability to user
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  assignVulnerability: async (req, res) => {
    try {
      const vulnerabilityId = req.params.id;
      const userId = req.params.userId;
      
      const updatedVulnerability = await vulnerabilityService.assignVulnerability(
        vulnerabilityId,
        userId
      );
      
      res.status(200).json({
        success: true,
        message: 'Vulnerability assigned successfully',
        data: updatedVulnerability
      });
    } catch (error) {
      logger.error(`Error in assignVulnerability controller: ${error.message}`);
      
      if (error.message.includes('not found')) {
        return res.status(404).json({
          success: false,
          message: error.message
        });
      }
      
      res.status(500).json({
        success: false,
        message: 'Error assigning vulnerability'
      });
    }
  },

  /**
   * Update vulnerability
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  updateVulnerability: async (req, res) => {
    try {
      const vulnerabilityId = req.params.id;
      const updateData = req.body;
      
      const updatedVulnerability = await vulnerabilityService.updateVulnerability(
        vulnerabilityId,
        updateData
      );
      
      res.status(200).json({
        success: true,
        message: 'Vulnerability updated successfully',
        data: updatedVulnerability
      });
    } catch (error) {
      logger.error(`Error in updateVulnerability controller: ${error.message}`);
      
      if (error.message.includes('not found')) {
        return res.status(404).json({
          success: false,
          message: 'Vulnerability not found'
        });
      }
      
      res.status(500).json({
        success: false,
        message: 'Error updating vulnerability'
      });
    }
  },

  /**
   * Get code snippet for vulnerability
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  getCodeSnippet: async (req, res) => {
    try {
      console.log('=== GET CODE SNIPPET DEBUG ===');
      console.log('Vulnerability ID:', req.params.id);
      console.log('Query params:', req.query);

      const vulnerabilityId = req.params.id;
      const contextLines = req.query.context ? parseInt(req.query.context) : 3;
      
      const snippet = await vulnerabilityService.getCodeSnippet(
        vulnerabilityId,
        contextLines
      );
      
      res.status(200).json({
        success: true,
        data: snippet
      });
    } catch (error) {
      console.error('Error message:', error.message);
      logger.error(`Error in getCodeSnippet controller: ${error.message}`);
      
      if (error.message.includes('not found')) {
        return res.status(404).json({
          success: false,
          message: error.message
        });
      }
      
      res.status(500).json({
        success: false,
        message: 'Error getting code snippet'
      });
    }
  },

  /**
   * Get all vulnerabilities with pagination and filtering
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  getAllVulnerabilities: async (req, res) => {
    try {
      const { 
        limit = 100, 
        skip = 0, 
        severity,
        type,
        tool,
        status,
        scan
      } = req.query;
      
      // Build filter
      const filter = {};
      if (severity) filter.severity = severity;
      if (type) filter.type = type;
      if (tool) filter.tool = tool;
      if (status) filter.status = status;
      if (scan) filter.scan = scan;
      
      const result = await vulnerabilityService.getVulnerabilities(
        filter,
        parseInt(limit),
        parseInt(skip)
      );
      
      res.status(200).json({
        success: true,
        data: result
      });
    } catch (error) {
      logger.error(`Error in getAllVulnerabilities controller: ${error.message}`);
      
      res.status(500).json({
        success: false,
        message: 'Error fetching vulnerabilities'
      });
    }
  },

  /**
   * Search vulnerabilities
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  searchVulnerabilities: async (req, res) => {
    try {
      const searchTerm = req.params.term;
      const { limit = 100, skip = 0 } = req.query;
      
      // Build filter from query params
      const filter = {};
      const allowedFilters = ['severity', 'type', 'tool', 'status', 'scan'];
      
      for (const key of allowedFilters) {
        if (req.query[key]) {
          filter[key] = req.query[key];
        }
      }
      
      const result = await vulnerabilityService.searchVulnerabilities(
        searchTerm,
        filter,
        parseInt(limit),
        parseInt(skip)
      );
      
      res.status(200).json({
        success: true,
        data: result
      });
    } catch (error) {
      logger.error(`Error in searchVulnerabilities controller: ${error.message}`);
      
      res.status(500).json({
        success: false,
        message: 'Error searching vulnerabilities'
      });
    }
  }
};

module.exports = vulnerabilityController;