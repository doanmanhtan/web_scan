// src/services/vulnerabilityService.js

const API_BASE_URL = process.env.REACT_APP_API_URL || '';

// Helper function to get auth headers
const getAuthHeaders = () => {
  const token = localStorage.getItem('token');
  return {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`,
  };
};

// Get all vulnerabilities
export const getVulnerabilities = async (filters = {}) => {
  try {
    const queryParams = new URLSearchParams();
    
    // Add filters to query params if provided
    if (filters.severity && filters.severity !== 'all') {
      queryParams.append('severity', filters.severity);
    }
    if (filters.tool && filters.tool !== 'all') {
      queryParams.append('tool', filters.tool);
    }
    if (filters.status && filters.status !== 'all') {
      queryParams.append('status', filters.status);
    }
    if (filters.scanId) {
      queryParams.append('scanId', filters.scanId);
    }
    if (filters.search) {
      queryParams.append('search', filters.search);
    }

    const url = queryParams.toString() 
      ? `${API_BASE_URL}/api/vulnerabilities?${queryParams.toString()}` 
      : `${API_BASE_URL}/api/vulnerabilities`;

    const response = await fetch(url, {
      method: 'GET',
      headers: getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching vulnerabilities:', error);
    throw error;
  }
};

// Get vulnerability by ID
export const getVulnerabilityById = async (id) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/vulnerabilities/${id}`, {
      method: 'GET',
      headers: getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching vulnerability:', error);
    throw error;
  }
};

// Update vulnerability status
export const updateVulnerabilityStatus = async (id, status) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/vulnerabilities/${id}/status`, {
      method: 'PATCH',
      headers: getAuthHeaders(),
      body: JSON.stringify({ status }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error updating vulnerability status:', error);
    throw error;
  }
};

// Get vulnerability statistics
export const getVulnerabilityStats = async () => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/vulnerabilities/stats`, {
      method: 'GET',
      headers: getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching vulnerability stats:', error);
    throw error;
  }
};

// Delete vulnerability
export const deleteVulnerability = async (id) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/vulnerabilities/${id}`, {
      method: 'DELETE',
      headers: getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return { success: true };
  } catch (error) {
    console.error('Error deleting vulnerability:', error);
    throw error;
  }
};

// Export vulnerabilities
export const exportVulnerabilities = async (format = 'json', filters = {}) => {
  try {
    const queryParams = new URLSearchParams();
    queryParams.append('format', format);
    
    // Add filters to query params
    Object.entries(filters).forEach(([key, value]) => {
      if (value && value !== 'all') {
        queryParams.append(key, value);
      }
    });

    const response = await fetch(`${API_BASE_URL}/api/vulnerabilities/export?${queryParams.toString()}`, {
      method: 'GET',
      headers: getAuthHeaders(),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Handle different response types based on format
    if (format === 'json') {
      return await response.json();
    } else {
      return await response.blob();
    }
  } catch (error) {
    console.error('Error exporting vulnerabilities:', error);
    throw error;
  }
};

// Bulk update vulnerability statuses
export const bulkUpdateStatus = async (vulnerabilityIds, status) => {
  try {
    const response = await fetch(`${API_BASE_URL}/api/vulnerabilities/bulk-update`, {
      method: 'PATCH',
      headers: getAuthHeaders(),
      body: JSON.stringify({ 
        vulnerabilityIds, 
        status 
      }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error bulk updating vulnerabilities:', error);
    throw error;
  }
};

// Create a service object with all functions
const vulnerabilityService = {
  getVulnerabilities,
  getVulnerabilityById,
  updateVulnerabilityStatus,
  getVulnerabilityStats,
  deleteVulnerability,
  exportVulnerabilities,
  bulkUpdateStatus,
};

export default vulnerabilityService;